<h1 id="header-about-node-js">About Node.js®</h1>
<p>
  As an asynchronous event-driven JavaScript runtime, Node.js is designed to
  build scalable network applications. In the following "hello world" example,
  many connections can be handled concurrently. Upon each connection, the
  callback is fired, but if there is no work to be done, Node.js will sleep.
</p>
<div class="code-box"></div>

<p>
  This is in contrast to today's more common concurrency model, in which OS
  threads are employed. Thread-based networking is relatively inefficient and
  very difficult to use. Furthermore, users of Node.js are free from worries of
  dead-locking the process, since there are no locks. Almost no function in
  Node.js directly performs I/O, so the process never blocks except when the I/O
  is performed using synchronous methods of Node.js standard library. Because
  nothing blocks, scalable systems are very reasonable to develop in Node.js.
</p>
<p>
  If some of this language is unfamiliar, there is a full article on
  <a href="/en/docs/guides/blocking-vs-non-blocking/"
    >Blocking vs. Non-Blocking</a
  >.
</p>
<hr />
<p>
  Node.js is similar in design to, and influenced by, systems like Ruby's
  <a href="https://github.com/eventmachine/eventmachine">Event Machine</a> and
  Python's <a href="https://twistedmatrix.com/trac/">Twisted</a>. Node.js takes
  the event model a bit further. It presents an
  <a href="/en/docs/guides/event-loop-timers-and-nexttick/">event loop</a> as a
  runtime construct instead of as a library. In other systems, there is always a
  blocking call to start the event-loop. Typically, behavior is defined through
  callbacks at the beginning of a script, and at the end a server is started
  through a blocking call like <code>EventMachine::run()</code>. In Node.js,
  there is no such start-the-event-loop call. Node.js simply enters the event
  loop after executing the input script. Node.js exits the event loop when there
  are no more callbacks to perform. This behavior is like browser JavaScript —
  the event loop is hidden from the user.
</p>
<p>
  HTTP is a first-class citizen in Node.js, designed with streaming and low
  latency in mind. This makes Node.js well suited for the foundation of a web
  library or framework.
</p>
<p>
  Node.js being designed without threads doesn't mean you can't take advantage
  of multiple cores in your environment. Child processes can be spawned by using
  our
  <a
    href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options"
    ><code>child_process.fork()</code></a
  >
  API, and are designed to be easy to communicate with. Built upon that same
  interface is the
  <a href="https://nodejs.org/api/cluster.html"><code>cluster</code></a> module,
  which allows you to share sockets between processes to enable load balancing
  over your cores.
</p>
